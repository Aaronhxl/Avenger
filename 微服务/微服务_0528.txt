 两套微服务解决方案：
	Spring Boot + Spring Cloud 组件多，功能完备
	Spring Boot + Dobbo + Zookeeper 组件少，功能完备

微服务架构遇到什么问题？分布式系统开发

最大的问题-》网络是不可靠的

四大问题	高可用-》一直可以用，要有副本（每个服务） 高并发 高性能
	1.客户端如何访问这么多的服务？
		API 网关
	2.服务与服务之间如何通信？
		同步通信
			HTTP：Apache Http Client
			RPC：Dubbo Grpc
		异步通信
			消息队列：Kafka RabbitMQ RocketMQ
	3.这么多服务，如何管理？
		服务治理：服务注册与发现
		基于客户端的服务注册与发现 Zookeeper
		基于服务端的服务注册与发现 Eureka
	4.服务挂了，怎么办？
		重试机制
		服务熔断
		服务降低
		服务限流

Zookeeper 分布式协调技术
	主要用来解决分布式环境当中多个进程之间的同步控制，让他们
	有序的去访问某种临界资源，防止造成“脏数据”的后果
	分布式环境下，用分布式锁去保证临界资源的有序访问，分布式锁是
	实现分布式协调技术的核心
分布式锁应该具备哪些条件？
	在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行
	高可用的获取锁与释放锁
	高性能的获取锁和释放锁
	具有可重入特性
	具备锁失效机制，防止死锁
	具备非阻塞锁的特性，即没有获取到锁将直接返回获取锁失败
分布式锁的实现有哪些？
	Memcached
	Redis
	Zookeeper：顺序临时节点，来实现分布式锁和等待队列，设置的初衷就是实现分布式服务的
	Chubby:Google实现的Paxos一致性算法

	Redis中的实现：
		加锁：
		1.先去redis里使用setnx命令（）相当于set,返回值为0，1
		2.发现redis里面有数据，说明已经加锁了
		3.发现redis里面没有数据，说明可以获得锁
		解锁：
		4.使用：del命令
		锁超时：
		5.设置超时：expire命令
		Java程序去完成实际操作redis
	三大问题
	原子问题：
	其中：应该把setnx、expire同时设置，原子操作，防止在setnx后宕机而无expire
	Redis提供了set(key,value,expire),原子操作
	误删锁：当进程1在expire时间内没有完成操作
		JVM1数据没有操作完成，30s，没操作完成
		操作完成，del，此时删除的是JVM2的锁
	解决方案：通过value判断是不是自己的锁
	基于第二问题：应引入加时机制，所以有守护进程，时间到了，操作没完成，守护进程申请加时
		




