1.类实例化：
	为新的对象分配内存
	为实例变量赋默认值
	为实例变量赋正确的初始值
	java编译器为它编译的每一个类都至少生成一个实例初始化方法，在
	Java的class文件中，这个实例初始化方法被称之为“<init>”。针对
	源代码中的每一个类的构造方法，Java编译器都产生一个<init>方法
2.类的加载的最终产品是位于内存中的Class对象
	class对象封装了类在方法区内的数据结构，并且向Java程序员提供了
	访问方法区内的数据结构的接口
3.有两种类型的类加载器
	Java虚拟机自带的加载器：
		根类加载器（Bootstrap）
		扩展类加载器（Extension）
		系统（应用）类加载器（Application）
	用户自定义的类加载器
		java.lang.ClassLoader的子类
		用户可以定制类的加载方式
4.类加载器并不需要等到某个类被首次“主动使用”时才去加载它
5.JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先
	加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序
	首次主动使用该类时才报告错误（LinkageError错误）
	如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
6.当Java虚拟机初始化一个类时，要求它的父类都已经被初始化，但是这条规则并不适用于接口
	在初始化一个类时，并不会先初始化它所实现的接口
	在初始化一个接口时，并不会先初始化它的父接口
	因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化
	只有当程序首次使用特定接口的静态变量时，才会导致接口的初始化	