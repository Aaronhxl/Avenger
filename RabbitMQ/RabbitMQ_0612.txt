各种应用模式：
	1.简单队列：一对一
	2.work queue：一个生产者-》多个消费者，大家都发配的一样的任务，无论
	现阶段机器的任务是咋样的，轮询策略
	3.fair dispatch：公平分发，能者多劳

消息应答与消息持久化：
	1.Boolean autoAck = true;（自动确认模式）一旦rabbitmq将消息
	分发给消费者，就会从内存中删除；
	这种情况下，如果消费者服务挂了，那么这个消息就丢了
	2.Boolean autoAck = false;(手动模式)，如果有一个消费者挂掉
	就会交付给其他消费者（没有收到回复消息的话，就认为是以及挂了）
	收到应答的意思是：消费者通知mq，这个消息我已经处理完毕了，你可以
	把内存中的这个消息删除了
	消息应答是默认打开的，false message ackonwlege
	
	消息持久化：如果mq挂了，那么在mq的内存中的消息将全部丢失
	所以，mq必须支持持久化
	Boolean durable = false；
	channel.queueDeclare(QUEUE_NAME,durable,false,false,null);
	我们将程序中的Boolean durable = false;改成true；是不可以的，
	尽管代码是正确的，他也不会运行成功，因为我们已经定义了一个
	叫test_work_queue,这个queue是未持久化的，mq不允许重新定义queue
	的属性


消息模式：
	1.订阅模式：
	模型不同：生产者--》交换机（exchange）-》mq-》消费者

	解读：
	1.一个生产者，多个消费者
	2.每一个消费者都有自己的队列
	3.生产者没有直接把消息发送到队列 而是直接发到了交换机转发器 exchange
	4.每个队列都要绑定到交换机上
	5.生产者发送的消息 经过交换机 到达队列 就能实现 一个消息被多个消费者消费
	
	注意：交换机没有存储的能力，在rabbitmq里面只有队列有存储能力，如果没有
	交换机没有绑定到队列，或者说没有队列绑定到交换机上，那么数据将会丢失
































