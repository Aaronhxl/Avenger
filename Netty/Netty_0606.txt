伪异步I/O：
	1.采用线程池实现，避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题
	但是底层的通信依然采用同步阻塞模型，因此无法从根本上解决问题
	2.由于线程池采用阻塞队列实现，当队列积满之后，后续入队列的操作将被阻塞，同时
	新的客户端请求消息将被拒绝，客户端会发生大量的连接超时
	3.由于几乎所有的连接都超时，调用者会认为系统已经崩溃，无法接收新的请求消息
NIO（官方New IO/Non-block IO）:非阻塞I/O
	1.缓冲区Buffer
	2.通道Channel，通道与流的不同之处在于通道是双向的，流只是在一个方向上移动（流
	必须是InputStream或者OutputStream的子类），而通道可以用于读、写或者二者同时进行
	Channel是全双工的，所以它可以比流更好地映射底层操作系统的API，特别是在UNIX网络
	编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作
	3.多路复用器Selector
	客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECT等待后续结果，
	不需要像之前的客户端那样被阻塞
	读取操作也是异步的
	线程模型优化--采用epoll

四种概念：
	1.异步非阻塞I/O：实际上不是NIO（非阻塞IO），异步I/O（AIO） P78
	2.NIO实现的关键就是多路复用技术，多路复用的核心就是通过Selector
	来轮询注册在其上的Channel
	3.伪异步I/O的概念完全来源于实践















