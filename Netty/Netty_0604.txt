网络I/O模型：
	系统调用recvfrom:函数用于从（已连接）套接口上接收数据，并捕获数据发送源的地址
	（1）阻塞I/O模型：再缺省情形下，所有文件操作都是阻塞的。以上述系统调用为例，该
	系统调用直到数据包到达且被复制到应用进程的缓冲区或者发生错误时才返回，在此期间
	一直会等待，即从开始系统调用到它返回的整段时间都是被阻塞的，故称为阻塞I/O模型
	（2）非阻塞I/O模型：recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就
	直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核
	是不是有数据到来
	（3）I/O复用模型：Linux提供select/poll，进程通过将一个或多个fd传递给select或poll
	系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态
	。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到一些制约。
	Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。
	当有fd就绪时，立即有回调函数rollback
	(4)信号驱动I/O模型：首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个
	信号处理函数（此函数调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就
	为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环
	函数处理数据
	(5)异步I/O：告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核区复制到用户
	自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O由内核通知我们何时
	可以开始一个I/O操作，异步I/O模型由内核通知我们I/O操作何时已经完成

	


介绍：
	Netty是异步的、事件驱动的、网络应用框架
	Staged Driver